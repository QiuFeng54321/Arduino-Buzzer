//
// Created by Qiufeng54321 on 2019-09-23.
// Copyright (C) 2019  Qiufeng54321
//
//    This program is free software: you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation, either version 3 of the License, or
//    (at your option) any later version.
//
//    This program is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with this program.  If not, see <https://www.gnu.org/licenses/>.
//

#include <Options.h>
#include "MidiFile.h"
#include "PITCH.hpp"

#include <iostream>
#include <cmath>
#include <iomanip>

extern std::map<int, std::string> pitchMap;

std::vector<int> track_pins(32);

int pin, tune;

std::map<int, int> sizeMap;

std::string getPitchEnum(int pitch) {
	for (int i = -2; i < 3; i++) {
		std::string name = pitchMap[pitch + i];
		if (!name.empty()) return name;
	}
}

void generateHead(smf::MidiFile &midiFile, std::ostream &out) {
	std::string comment_info_head = "//\t\t";
	out << "//The code below is generated by Buzzer-Midi-Convert by Qiufeng54321." << std::endl;
	out << "//Midi info:" << std::endl;
	out << comment_info_head << "Generated for midi file " << midiFile.getFilename() << std::endl;
	out << comment_info_head << "Tracks \t\t: " << midiFile.getTrackCount() << std::endl;
	out << comment_info_head << "Duration \t: " << midiFile.getFileDurationInSeconds() << "s" << std::endl;
	out << comment_info_head << "Pin \t\t: " << pin << std::endl;
	out << comment_info_head << "Pitch Change: " << tune << std::endl;
	out << comment_info_head << "Tracks info: " << std::endl;
	for (int track = 0; track < midiFile.getTrackCount(); track++) {
		out << comment_info_head << "\tTrack " << std::setw(8) << std::left << track << " has " << std::setw(8)
			<< std::left << midiFile[track].getEventCount() << " events." << std::endl;
	}
}

void generateActions(smf::MidiFile &midiFile, std::ostream &out) {
	double lastNoteFinished = 0;
	int defaultTempo = 120;
//	int TPQ = midiFile.getTicksPerQuarterNote();
	for (int track = 0; track < midiFile.getTrackCount(); track++) {
//		out << midiFile[track].size() << std::endl;
		out << "NoteAction track" << track << "[]{" << std::endl;
		int actualSize = 0;
		for (int i = 0; i < midiFile[track].size(); i++) {
			smf::MidiEvent *mev = &midiFile[track][i];
//			if(!mev) continue;
			defaultTempo = mev->getTempoBPM() > 0 ? mev->getTempoBPM() : defaultTempo;
			if (!mev->isNoteOn() || mev->getLinkedEvent() == nullptr) {
				continue;
			}
			// pause, silence
			int silence = static_cast<int>((midiFile.getTimeInSeconds(mev->tick) - lastNoteFinished) * 1000);
			if (silence > 0) {
				out << "\t{" << silence << "}," << std::endl;
				actualSize++;
			}
			double duration = mev->getDurationInSeconds();

			int halfTonesFromA4 = mev->getKeyNumber() - 69; // 69 == A4 == 440Hz
			int frq = 440 * pow(2, (halfTonesFromA4 + tune) / 12.0) - 1;
			int frq_old = 440 * pow(2, (halfTonesFromA4 + tune) / 12.0) - 1;
//			std::cout << "frq: " << frq << ", frq_old: " << frq_old << std::endl;
			std::string freq_enum = getPitchEnum(frq);
			// play note
			int dura_milli = duration * 1000;

//			out << "{" << dura_milli << ", " << frq << "}," << std::endl;
			out << "\t{" << dura_milli << ", Pitch::" << freq_enum << "}," << std::endl;

			actualSize++;

			smf::MidiEvent *off = mev->getLinkedEvent();
			lastNoteFinished = midiFile.getTimeInSeconds(off->tick);
		}
		sizeMap[track] = actualSize;
		out << "\b};" << std::endl;
	}
	out << "Tempo tempo{" << defaultTempo << "};" << std::endl;
}

void generateChannel(smf::MidiFile &midiFile, std::ostream &out, int track) {
	out << "Channel channel" << track << "{patternList" << track << ", 1, " << track_pins[track] << "};" << std::endl;
}

void generatePatternList(smf::MidiFile &midiFile, std::ostream &out) {
	for (int track = 0; track < midiFile.getTrackCount(); track++) {
		out << "Pattern patternList" << track << "[]{" << "{track" << track << ", " << sizeMap[track] << "}};"
			<< std::endl;
		generateChannel(midiFile, out, track);
		out << std::endl;
	}
}


void generate(smf::MidiFile &midiFile, std::ostream &out) {
	generateHead(midiFile, std::cout);
	generateActions(midiFile, out);
	generatePatternList(midiFile, out);
}

int main(int argc, char **argv) {
	smf::Options options;
	options.define("p|pin=i:8");
	options.define("t|tune=i:0", "In/Decrease all pitches by a value");
	options.process(argc, argv);
	pin = options.getInteger("pin");
	tune = options.getInteger("tune");
	std::fill(track_pins.begin(), track_pins.end(), pin);
	smf::MidiFile midiFile;
	midiFile.read(options.getArg(1));
//	midiFile.read("/williamye/mid_determination.mid");
	midiFile.doTimeAnalysis();
	midiFile.linkNotePairs();
	midiFile.absoluteTicks();
	midiFile.splitTracks();
	generate(midiFile, std::cout);
}


#include "../../global/PitchMap.hpp"